<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Adding meta -->
    
    
    <meta name="authors" content="Tobi and MakeShiftArtist" />
    
    <meta name="description" content="iFunny api wrapper written in node.js" />
    
    

    <!-- Adding external script-->
    

    <!-- Adding external style-->
    

    <!-- Adding scripts-->
    

    <!-- Adding style-->
    

    <!-- Adding overlay script-->
    

    <!-- Adding overlay style-->
    


    <title>
      src/Client.js
    </title>

    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/third-party/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/third-party/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/reset.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-base.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-light.css">
    
    <svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
    style="display:none">
    <defs>
        <symbol id="copy-icon" viewbox="0 0 488.3 488.3">
            <g>
                <path
                    d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z" />
                <path
                    d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z" />
            </g>
        </symbol>
        <symbol id='search-icon' viewBox="0 0 512 512">
            <g>
                <g>
                    <path
                        d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z" />
                </g>
            </g>
            <g>
                <g>
                    <path
                        d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z" />
                </g>
            </g>
        </symbol>
        <symbol id="down-icon" viewBox="0 0 16 16">
            <path 
                fill-rule="evenodd" 
                clip-rule="evenodd" 
                d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"
            >
            </path>
        </symbol>
    </defs>
</svg>
  </head>

  <body>

    <nav class="navbar" id="navbar">
      <div class="navbar-heading" id="navbar-heading"><a href="index.html"><h2 class="navbar-heading-text">Home</h2></a></div><div class="search-box" id="search-box"><div class="search-box-input-container"><input class="search-box-input" type="text" placeholder="Search..." id="search-box-input" /><svg class="search-icon" alt="search-icon"><use xlink:href="#search-icon"></use></svg></div><div class="search-item-container" id="search-item-container"><ul class="search-item-ul" id="search-item-ul"></ul></div></div><div class="sidebar-main-content" id="sidebar-main-content"><ul><li class="menu-li"><a href='https://github.com/ifunny-co/ifunny.js' class='some-class menu-link' id='some-id' target='_blank'>GitHub</a></li></ul><div class="accordion collapsed" id="7716434" > <h3 class="accordion-heading">Classes<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion collapsed child" id=4033201><div class="accordion-heading child"><a href="Channel.html">Channel</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Channel.html#acceptInvite">acceptInvite</a></li><li data-type='method'><a href="Channel.html#members">members</a></li><li data-type='method'><a href="Channel.html#send">send</a></li><li data-type='method'><a href="Channel.html#sendPriority">sendPriority</a></li></ul></li><li class="accordion collapsed child" id=2579998><div class="accordion-heading child"><a href="Client.html">Client</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Client.html#connect">connect</a></li><li data-type='method'><a href="Client.html#listContacts">listContacts</a></li><li data-type='method'><a href="Client.html#searchContacts">searchContacts</a></li><li data-type='method'><a href="Client.html#userById">userById</a></li><li data-type='method'><a href="Client.html#userByNick">userByNick</a></li></ul></li><li class="accordion-list" id=""><a href="CommandInstance.html">CommandInstance</a></li><li class="accordion collapsed child" id=2775771><div class="accordion-heading child"><a href="User.html">User</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="User.html#createChat">createChat</a></li></ul></li></ul> </div><div class="accordion collapsed" id="7383080" > <h3 class="accordion-heading">Global<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion-list" id=""><a href="global.html#copy">copy</a></li><li class="accordion-list" id=""><a href="global.html#e">e</a></li><li class="accordion-list" id=""><a href="global.html#getAccordionIdsFromLocalStorage">getAccordionIdsFromLocalStorage</a></li><li class="accordion-list" id=""><a href="global.html#removeAccordionIdFromLocalStorage">removeAccordionIdFromLocalStorage</a></li><li class="accordion-list" id=""><a href="global.html#setAccordionIdToLocalStorage">setAccordionIdToLocalStorage</a></li><li class="accordion-list" id=""><a href="global.html#toggleNavbar">toggleNavbar</a></li></ul> </div></div>
      

    </nav>
    <div class="navbar-ham" id="navbar-ham">
      <div>
        <div class="first"></div>
        <div class="second"></div>
        <div class="third"></div>
      </div>
    </div>

    <div id="main" class="main-content">
      
      <h1 id='page-title' class="page-title">
        src/Client.js
      </h1>
      

      



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const Wampy  = require("wampy").Wampy
const WampyPatch = require("./WampyPatch")
const websocket = require("ws")
const Channel = require("./Channel")
const User = require("./User")
const {create, AxiosRequestConfig, AxiosInstance} = require("axios")

class Client extends require("events").EventEmitter {

    /**
     * Client for initializing the websocket (non connected state) and general client information
     * @param {Object} ClientOpts - User fed options for the client to run with
     * @param {string} ClientOpts.bearer - Bearer token for your iFunny account
     * @param {string} ClientOpts.uid - User ID for your iFunny account
     * @param {string} [ClientOpts.basic=null] - Basic token for your iFunny account
     * @param {boolean} [ClientOpts.autoAcceptInvite=true] - Set account to automatically accept invites as they come
     * @param {boolean} [ClientOpts.debugWampy=false] - Setting to turn on wampy debugging
     * @param {boolean} [ClientOpts.debug=false] - Setting to turn on logging
     */
    constructor(ClientOpts) {
        super()

        /**
         * Bearer token for iFunny WebSocket and HTTP Authorization
         * @type {string}
         * @private
         */
        this._bearer = ClientOpts.bearer

        /**
         * Basic Authorization token for iFunny HTTP Authorization (limited use-case)
         * @type {string|null}
         * @private
         */
        this._basic = ClientOpts.basic || null

        /**
         * Unique User ID Associated with bearer used for Authentication
         * @type {string}
         * @private
         */
        this._uid = ClientOpts.uid

        /**
         * WebSocket host url for iFunny chats
         * @type {string}
         * @private
         */
        this._wshost = "chat.ifunny.co"

        /**
         * Value on whether or not to log wampy dump to console
         * @type {boolean}
         * @private
         */
        this._debugWampy = ClientOpts.debugWampy || false

        /**
         * Value on whether to display general log details to console
         * @type {boolean}
         * @private
         */
        this._debug = ClientOpts.debug || false

        /**
         * Decides whether or not the WebSocket should automatically accept invites from users.
         * @type {boolean}
         * @private
         */
        this._autoAcceptInvite = ClientOpts.autoAcceptInvite || true

        /**
         * Queud messages array for message processing
         * @type {Array.&lt;{name: string, content: string, callback: Object|function, nick: string}>}
         * @private
         */
        this._queudMessages = []

        /**
         * Queud messages array for message processing
         * @type {Array.&lt;{name: string, content: string, callback: Object|function, nick: string}>}
         * @private
         */
        this._priorityMessages = []

        /**
         * API Host for iFunnys mobile api
         * @type {string}
         * @private
         */
        this._host = "https://api.ifunny.mobi/v4"

        /**
         * Request instance for axios for connection reuse
         * @type {AxiosInstance}
         * @private
         */
        this._axiosInstance = create({ baseURL: this._host })
        this._axiosInstance.defaults.headers.Authorization = `Bearer ${this._bearer}`
        this._axiosInstance.defaults.headers["Ifunny-Project-Id"] = "iFunny"

        /**
         * WebSocket/Wampy instance for connecting to chats, connection not in state.
         * @type {wampy}
         * @private
         */
        this._ws = new Wampy(`wss://${this._wshost}/chat`)

        this._ws.options({
            ws: websocket,
            realm: "co.fun.chat.ifunny",
            authid: this._uid,
            authmethods: ['ticket'],
            onChallenge: (method, info) =>{
                this._log("Challenge issued..")
                return this._bearer
            },
            onConnect: (info) => {
                console.log(`Logged in as ${info.attributes.nick}`)
                this.emit("connected", info)
            },
            onError: (error) => {
                console.log(error)
            },
            debug: this._debugWampy
        })
    }

    /**
     * Handles the response of HTTP requests made to the iFunny api
     * @param {function|Object} callback - Function to call after the response is wrapped
     * @returns {function} - Returns a wrapped function that handles callback
     * @private
     */
    _handleResponse(callback) {
        return function(req) {
            if (callback) {
                if (req.data) {
                    callback(req.data.data)
                } else if (req.response) {
                    callback(req.response.data)
                } else {
                    //Handle in future if not error but also not success
                }
            }
        }
    }

    /**
     * Handles getting the headers based on whether or not a basic or bearer token is needed for the request
     * @param {boolean} basic - Decides whether or not a basic is needed for the request
     * @returns {{Ifunny-Project-Id:string, Authorization: string}} - Final headers for authorization
     * @private
     */
    _headers(basic=false) {

        let baseHeaders = { "Ifunny-Project-Id": "iFunny" }

        if (basic &amp;&amp; this._basic) {
            return { Authorization: `Basic ${this._basic}`, ...baseHeaders }
        } else return { Authorization: `Bearer ${this._bearer}`, ...baseHeaders }
    }

    /**
     * Makes a request using Basic Authorization token
     * @param {AxiosRequestConfig} opts - Request config
     * @param {{Authorization: string}} opts.headers - Headers for request config
     * @param {function|Object} callback - Callback for response
     * @private
     */
    async _basicRequest(opts, callback) { //If theres no basic token in the client, then it will use bearer by default.
        this._axiosInstance({headers: this._headers(true), ...opts}).then(this._handleResponse(callback)).catch(this._handleResponse(callback))
    }

    /**
     * Makes a request using Bearer token
     * @param {AxiosRequestConfig} opts - Request config
     * @param {{Authorization: string}} opts.headers - Headers for request config
     * @param {function|Object} callback - Callback for response
     * @private
     */
    async _request(opts, callback) {
        this._axiosInstance({headers: this._headers(false), ...opts}).then(this._handleResponse(callback)).catch(this._handleResponse(callback))
    }

    /**
     * Checks debug settings and logs to console
     * @param {*} params - Logs any arguments
     * @private
     */
    _log() {
        if (this._debug) {
            console.log(...arguments)
        }
    }

    /**
     * Creates a new Channel instance for each channel in a new chat message and sends it to the message emitter when the onOpen event happens with wampy
     * @param {Object} data - Not typing this data, but its channel data for chats and messages, will type it out in Channel.js likely.
     * @private
     */
    _handleChats (data) {
        for (let index in data.argsDict.chats) {
            let chat = data.argsDict.chats[index]
            let channel = new Channel(this, chat)
            this.emit("message", channel)
        }
    }

    /**
     * Creates a new Channel instance for each channel in the invite list and sees if it needs to autoAccept messages when the onOpen event happens with wampy
     * @param {Object} data - Not typing this data, but its channel data for chats and messages, will type it out in Channel.js likely.
     * @private
     */
    _handleInvites (data) {
        let channels = []
        for (let index in data.argsDict.chats) {
            let chat = data.argsDict.chats[index]
            let channel = new Channel(this, chat)
            channels.push(channel)
            if (this._autoAcceptInvite) {
                channel.acceptInvite()
            }
        }
        this.emit("invites", channels)
    }

    /**
     * Connects to the iFunny chat WebSocket, and subscribes to chats and invites
     * @param {function|Object} callback - adds a connection callback to the client emitter
     * @public
     */
    connect(callback) {
        if (typeof callback == "function") {
            this.on("connected", callback)
        }
        WampyPatch(this._ws)
        this._ws.connect()
        this._handleQueuedMessages()
        this._ws.subscribe(`co.fun.chat.user.${this._uid}.invites`, this._handleInvites.bind(this))
        this._ws.subscribe(`co.fun.chat.user.${this._uid}.chats`, this._handleChats.bind(this))
        this._log(this._ws)
    }

    /**
     * Accepts an invite from a channel
     * @param {string} channelName - ID of channel to accept, keyword is name in iFunnt chats.
     * @private
     */
    _acceptInvite(channelName) {
        this._ws.call("co.fun.chat.invite.accept", [channelName], {
            onSuccess: result => {
                this._log(`Joined channel ${channelName}`)
            },
            onError: err => {
                throw err
            }
        })
    }

    /**
     * Sorts queud messages and runs them into the WebSocket in order
     * @param {number} timeout - Number of miliseconds to wait before sending the next messages
     * @private 
     */
    async _handleQueuedMessages(timeout=0) {

        function _handlePriorityMessages() {
            let priorityMessages = this._priorityMessages
            for (let index in priorityMessages) {
                this._queudMessages.unshift(priorityMessages[index])
                this._priorityMessages.shift()
            }
        }

        setTimeout( function() {
            let message = this._queudMessages[0]
            let content = ""
            let contents = {}

            if (message) {

                let callbacks = []
                //Add support for speed when not rate limited.

                for (let index in this._queudMessages) {
                    let indexedQueuedMessage = this._queudMessages[index]
                    if (indexedQueuedMessage.name == message.name) {
                        let totalLength = 0
                        for (let name in contents) {
                            totalLength += name.length
                            totalLength += 2
                            totalLength += contents[name].length
                        }
                        if (contents[indexedQueuedMessage.nick]) {
                            if ((totalLength + indexedQueuedMessage.content.length + 2) &lt; 5000) {
                                contents[indexedQueuedMessage.nick] = `${contents[indexedQueuedMessage.nick]}${indexedQueuedMessage.content}\n\n`
                                callbacks.push(indexedQueuedMessage.callback)
                                delete this._queudMessages[index]
                            }
                        } else {
                            let queudMessageLength = indexedQueuedMessage.nick.length + 2 + indexedQueuedMessage.content.length //This is to account for escape character and :
                            if (totalLength + queudMessageLength &lt; 5000) {
                                contents[indexedQueuedMessage.nick] = `${indexedQueuedMessage.content}\n\n`
                                callbacks.push(indexedQueuedMessage.callback)
                                delete this._queudMessages[index]
                            }
                        }

                    }
                }

                for (let name in contents) {
                    content += `${name}:\n${contents[name]}\n`
                }

                this._sendMessage(message.name, content.slice(0, -3), function(data) {
                    if (data.error) {
                        if (data.error == "wamp.error.authorization_failed") {
                            this._handleQueuedMessages(1000)
                        }
                    } else {
                        this._queudMessages.shift()
                        _handlePriorityMessages.bind(this)()


                        async function handleCallback(callback) {
                            if (callback) {
                                callback(data)
                            }
                        }
                        for (let index in callbacks) {
                            handleCallback(callbacks[index])
                        }
                        this._handleQueuedMessages(3050)
                    }
                }.bind(this))
            } else {
                this._queudMessages.shift()
                _handlePriorityMessages.bind(this)()
                this._handleQueuedMessages()
            }

        }.bind(this), timeout)
    }

    /**
     * Adds message to the queue list to be sent in order
     * @param {string} channelName - Channel ID (name is key in iFunny chats) for sending message
     * @param {string} message - Content of message to add to the queue
     * @param {string} nick - Name of the user to add to the queue
     * @param {function|Object} [callback=undefined] - Callback of message to add
     * @private
     */
    _addToMessageQueue(channelName, message, nick, callback)  {
        this._queudMessages.push({
            name: channelName,
            content: message,
            callback: callback,
            nick: nick
        })
    }

    /**
     * Adds message to the queue list to be sent in priority (to the front of the queue)
     * @param {string} channelName - Channel ID (name is key in iFunny chats) for sending message
     * @param {string} message - Content of message to add to the queue
     * @param {string} nick - Name of the user to add to the queue
     * @param {function|Object} [callback=undefined] - Callback of message to add
     * @private
     */
    _addToPriorityMessageQueue(channelName, message, nick, callback) {
        this._priorityMessages.push({
            name: channelName,
            content: message,
            callback: callback,
            nick: nick
        })
    }

    /**
     * Sends message to the WebSocket of iFunny Chats
     * @param {string} channelName - Channel id (name is key in iFunny chats) for sending message
     * @param {string} message - Content of message to send
     * @param {function|Object} [callback=null] - Callback to run after the message is sent. 
     * @private
     */
    _sendMessage(channelName, message, callback=null) {
        this._ws.publish(`co.fun.chat.chat.${channelName}`, [200, 1, message], {
            onSuccess: result => {
                if (callback) {
                    callback({ timestamp: (new Date()).getTime(), ...result })
                }
            },
            onError: callback
        })
    }

    /**
     * Function for listing contacts for chats
     * @param {Object} opts - Options for listing contacts
     * @param {string} opts.chat_name - Chat name is the variable but based on UI I believe this is actually nickname
     * @param {number} opts.limit - Limit of users to return
     * @param {function|Object} callback - Function for sending user list or error
     */
    listContacts(opts={}, callback) {
        let users = []

        this._ws.call("co.fun.chat.list_contacts", { chat_name: opts.chat_name || null, limit: opts.limit || 100 }, {
            onSuccess: function(data) {
                for (let index in data.argsDict.users) {
                    users.push(new User(this, data.argsDict.users[index]))
                }
                callback(users)
            }.bind(this),
            onError: data => callback(data)
        })
    }

    /**
     * Function for searching through contacts for chats (Not working needs fixed apparently? Probably more options need added)
     * @param {Object} opts - Options for listing contacts
     * @param {string} opts.chat_name - Chat name is the variable but based on UI I believe this is actually nickname
     * @param {number} opts.limit - Limit of users to return
     * @param {string} opts.query - Query to search through contacts
     * @param {function|Object} callback - Function for sending user list or error
     * @public
     */
    searchContacts(opts, callback) {
        let users = []

        this._ws.call("co.fun.chat.search_contacts", { chat_name: opts.chat_name || null, limit: opts.limit || 100, query: opts.query }, {
            onSuccess: function(data) {
                for (let index in data.argsDict.users) {
                    users.push(new User(this, data.argsDict.users[index]))
                }
                callback(users)
            }.bind(this),
            onError: callback
        })
    }

    /**
     * Returns a user object by querying a nickname
     * @param {Object} opts - Options object
     * @param {string} opts.nick - nickname of user to be queried
     * @param {function|Object} callback - Callback for response
     * @public
     */
    userByNick(opts={}, callback) {
        this._request({ url: `/users/by_nick/${opts.nick}` }, function(response) {
            if (!response.error) {
                callback(new User(this, response, true))
            } else if (response.error == "not_found") {
                callback(response)
            } else { } //Handle response elsewhere
        }.bind(this))
    }

    /**
     * Returns a user object by querying an id
     * @param {Object} opts - Options object
     * @param {string} opts.id - id of user to be queried
     * @param {function|Object} callback - Callback for response
     * @public
     */
    userById(opts={}, callback) {
        this._request({ url: `/users/${opts.id}` }, function(response) {
            if (!response.error) {
                callback(new User(this, response, true))
            } else if (response.error == "not_found") {
                callback(response)
            } else { } //Handle response elsewhere
        }.bind(this))
    }
}

module.exports = Client</code></pre>
        </article>
    </section>




    </div>

    <footer class="footer" id="footer">
      
    </footer>

    <script src="scripts/third-party/prettify.js"></script>
    <script src="scripts/third-party/lang-css.js"></script>
    <script type="text/javascript" src="scripts/misc.js"></script>

    <script>prettyPrint();</script>
    <script src="scripts/linenumber.js"></script>
    <script src="scripts/fix-code-block.js"></script>
    <script src="scripts/fix-navbar.js"></script>
    
      <script src="scripts/search.js"></script>
      <script src="scripts/third-party/fuse.js"></script>
      <script>
        var list = [{"title":"Channel","link":"<a href=\"Channel.html\">Channel</a>"},{"title":"Channel#acceptInvite","link":"<a href=\"Channel.html#acceptInvite\">Channel &rtrif; acceptInvite</a>"},{"title":"Channel#members","link":"<a href=\"Channel.html#members\">Channel &rtrif; members</a>"},{"title":"Channel#send","link":"<a href=\"Channel.html#send\">Channel &rtrif; send</a>"},{"title":"Channel#sendPriority","link":"<a href=\"Channel.html#sendPriority\">Channel &rtrif; sendPriority</a>"},{"title":"Client","link":"<a href=\"Client.html\">Client</a>"},{"title":"Client#connect","link":"<a href=\"Client.html#connect\">Client &rtrif; connect</a>"},{"title":"Client#listContacts","link":"<a href=\"Client.html#listContacts\">Client &rtrif; listContacts</a>"},{"title":"Client#searchContacts","link":"<a href=\"Client.html#searchContacts\">Client &rtrif; searchContacts</a>"},{"title":"Client#userById","link":"<a href=\"Client.html#userById\">Client &rtrif; userById</a>"},{"title":"Client#userByNick","link":"<a href=\"Client.html#userByNick\">Client &rtrif; userByNick</a>"},{"title":"CommandInstance","link":"<a href=\"CommandInstance.html\">CommandInstance</a>"},{"title":"User","link":"<a href=\"User.html\">User</a>"},{"title":"User#createChat","link":"<a href=\"User.html#createChat\">User &rtrif; createChat</a>"},{"title":"copy","link":"<a href=\"global.html#copy\">copy</a>"},{"title":"e","link":"<a href=\"global.html#e\">e</a>"},{"title":"getAccordionIdsFromLocalStorage","link":"<a href=\"global.html#getAccordionIdsFromLocalStorage\">getAccordionIdsFromLocalStorage</a>"},{"title":"removeAccordionIdFromLocalStorage","link":"<a href=\"global.html#removeAccordionIdFromLocalStorage\">removeAccordionIdFromLocalStorage</a>"},{"title":"setAccordionIdToLocalStorage","link":"<a href=\"global.html#setAccordionIdToLocalStorage\">setAccordionIdToLocalStorage</a>"},{"title":"toggleNavbar","link":"<a href=\"global.html#toggleNavbar\">toggleNavbar</a>"}];
        var options = 
          setupSearch(list, options)
      </script>
    

    

    

    

    


  </body>

</html>
